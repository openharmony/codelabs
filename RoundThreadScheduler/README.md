ArkTS Round Thread Safe Scheduler 示例
一、项目简介

本示例工程基于 OpenHarmony ArkTS，演示了在 不依赖底层线程与高风险并发 API 的前提下，如何通过调度器设计思想实现：

多“任务”对共享数据的安全访问

按“轮次（Round）”有序执行

保证每一轮任务全部完成后再进入下一轮

全流程状态可视化展示

该示例适合作为 ArkTS 并发思想教学示例 / Codelab 示例 / 实验课程项目。

二、设计目标

本项目主要解决以下问题：

多个并发任务同时操作共享数据时，如何避免数据竞争

如何保证：

每一轮任务执行完成

再进入下一轮执行

在 ArkTS 中，如何用结构化调度逻辑替代直接使用底层线程 API

如何将调度过程可视化，便于理解并发执行过程

三、整体架构说明

项目采用 分层 + 职责清晰 的结构设计：

UI（Index.ets）
│
├── Scheduler（调度层）
│   ├── RoundScheduler        轮次调度核心
│   ├── ThreadManager         任务管理与派发
│   └── RoundBarrier          轮次完成同步控制
│
├── Worker（任务层）
│   └── IncrementWorker       单个任务逻辑
│
├── Model（状态层）
│   ├── SharedState           共享数据模型
│   ├── RoundState            当前轮次状态
│   └── ThreadLog             执行日志模型
│
└── Utils（工具层）
└── Logger                日志统一输出


四、核心思想说明
1️⃣ 轮次调度思想

所有任务按轮次执行

每一轮包含固定数量的任务

必须保证：

当前轮次的所有任务执行完成

才能进入下一轮

该机制在逻辑上等价于“并发系统中的 Barrier”。

2️⃣ 共享数据安全访问

本示例中：

所有任务 不直接修改 UI

所有共享数据封装在 SharedState 中

共享数据的修改 通过调度器统一控制

从结构上避免了数据竞争，而不是依赖底层锁或原子操作。


五、执行流程说明

用户在 UI 页面点击“开始执行”

RoundScheduler 初始化：

轮次数

每轮任务数

调度器创建多个 IncrementWorker

Worker 执行任务逻辑：

读取当前共享值

按规则递增

上报完成状态

RoundBarrier 统计完成情况

当本轮全部完成：

进入下一轮

所有轮次完成后：

输出最终结果

在 UI 中展示执行日志

六、示例效果

实时展示当前轮次

展示共享数据变化过程

显示每个任务的执行顺序

最终结果可验证正确性（如累加结果）

七、适用场景

ArkTS 并发思想教学

OpenHarmony Codelab 示例

并发调度设计示例

课程实验 / 作业示例