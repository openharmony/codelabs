/*
 * Copyright (c) 2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// src/main/ets/viewmodel/EventViewModel.ets
import { Event, EventModel } from '../model/EventModel';
import { DateUtils } from '../common/utils/DateUtils';
import { Logger } from '../common/utils/Logger';

/**
 * ğŸ“ [æ–°å¢] å®šä¹‰çŠ¶æ€è¿”å›æ¥å£
 * å› ä¸ºæœ¬æ–‡ä»¶æ˜¯é€»è¾‘å±‚(.ts)ï¼Œæ— æ³•ç›´æ¥è¿”å› $rå¯¹è±¡ï¼Œ
 * æ‰€ä»¥è¿”å› Key å’Œ å‚æ•°ï¼Œç”± UI å±‚é€šè¿‡ $r('app.string.' + key, param) è§£æ
 */
export interface EventStatusInfo {
  key: string; // string.json ä¸­çš„é”®å
  param?: number; // åŠ¨æ€å‚æ•° (å¦‚: 3å¤©å çš„ 3)
}

/**
 * æ—¥ç¨‹ä¸šåŠ¡é€»è¾‘æ¨¡å‹ (ViewModel)
 * å¤„ç†æ—¥ç¨‹å†²çªæ£€æµ‹ã€çŠ¶æ€åˆ¤æ–­ã€æ—¶é—´è®¡ç®—ç­‰å¤æ‚ä¸šåŠ¡
 */
export class EventViewModel {
  private logger = new Logger('EventViewModel');

  /**
   * æ£€æŸ¥æ—¥ç¨‹èµ·æ­¢æ—¶é—´æ˜¯å¦åˆæ³•
   */
  public validateEventTime(start: number, end: number): boolean {
    if (start >= end) {
      this.logger.warn('Validate failed: Start time must be before end time');
      return false;
    }
    return true;
  }

  /**
   * æ£€æŸ¥æ˜¯å¦ä¸ç°æœ‰æ—¥ç¨‹å†²çª
   */
  public async checkConflict(startTime: number, endTime: number, excludeId?: number): Promise<boolean> {
    this.logger.info('Checking for event conflicts...');

    try {
      const allEvents = await EventModel.queryUpcoming();

      for (const event of allEvents) {
        if (excludeId && event.id === excludeId) {
          continue;
        }

        const overlapStart = Math.max(startTime, event.startTime);
        const overlapEnd = Math.min(endTime, event.endTime);

        if (overlapStart < overlapEnd) {
          this.logger.warn(`Conflict detected with event: "${event.title}" (${DateUtils.formatFull(event.startTime)})`);
          return true; // å­˜åœ¨å†²çª
        }
      }
    } catch (e) {
      this.logger.error('Check conflict failed');
    }

    return false; // æ— å†²çª
  }

  /**
   * ğŸ“ [ä¿®æ”¹] è·å–æ—¥ç¨‹çš„çŠ¶æ€ä¿¡æ¯
   * åŸæ–¹æ³•å: getEventStatusText -> å»ºè®®æ”¹ä¸º getEventStatusInfo
   * @param event
   * @returns EventStatusInfo åŒ…å«èµ„æºKeyå’Œå‚æ•°
   */
  public getEventStatusInfo(event: Event): EventStatusInfo {
    const now = Date.now();

    if (now > event.endTime) {
      // å¯¹åº”: "å·²ç»“æŸ" -> calendar_status_ended
      return { key: 'calendar_status_ended' };
    } else if (now >= event.startTime && now <= event.endTime) {
      // å¯¹åº”: "è¿›è¡Œä¸­" -> calendar_status_ongoing
      return { key: 'calendar_status_ongoing' };
    } else {
      // è®¡ç®—è¿˜æœ‰å¤šä¹…å¼€å§‹
      const diff = event.startTime - now;
      const hours = Math.floor(diff / (3600 * 1000));

      if (hours > 48) {
        const days = Math.floor(hours / 24);
        // å¯¹åº”: "%då¤©å" -> calendar_time_days_later
        return { key: 'calendar_time_days_later', param: days };
      } else if (hours > 24) {
        // å¯¹åº”: "æ˜å¤©" -> calendar_time_tomorrow
        return { key: 'calendar_time_tomorrow' };
      } else if (hours > 0) {
        // å¯¹åº”: "%då°æ—¶å" -> calendar_time_hours_later
        return { key: 'calendar_time_hours_later', param: hours };
      } else {
        const mins = Math.floor(diff / (60 * 1000));
        // å¯¹åº”: "%dåˆ†é’Ÿå" -> calendar_time_mins_later
        return { key: 'calendar_time_mins_later', param: Math.max(1, mins) };
      }
    }
  }

  /**
   * è·å–æ—¥ç¨‹çŠ¶æ€å¯¹åº”çš„é¢œè‰²èµ„æº (ç”¨äº UI å±•ç¤º)
   * @param event
   */
  public getEventStatusColor(event: Event): string {
    const now = Date.now();
    if (now > event.endTime) {
      return '#999999'; // ç°è‰² - å·²ç»“æŸ
    } else if (now >= event.startTime && now <= event.endTime) {
      return '#007DFF'; // è“è‰² - è¿›è¡Œä¸­
    } else {
      return '#FF9C00'; // æ©™è‰² - æœªå¼€å§‹
    }
  }

  /**
   * å°†æ—¥ç¨‹æŒ‰æ—¥æœŸåˆ†ç»„ (Group By Date)
   */
  public groupEventsByDate(events: Array<Event>): Map<string, Array<Event>> {
    const map = new Map<string, Array<Event>>();

    events.forEach(event => {
      const dateKey = DateUtils.formatDate(event.startTime);
      if (!map.has(dateKey)) {
        map.set(dateKey, []);
      }
      map.get(dateKey)?.push(event);
    });

    return map;
  }
}