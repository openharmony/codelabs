/*
 * Copyright (c) 2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// PAP/PersonalAssistantPro/entry/src/main/ets/services/NotificationService.ets
import reminderAgentManager from '@ohos.reminderAgentManager';
import notificationManager from '@ohos.notificationManager';
import common from '@ohos.app.ability.common';
import wantAgent from '@ohos.app.ability.wantAgent';
import { Logger } from '../common/utils/Logger';

const logger = new Logger('NotificationService');

export class NotificationService {
  /**
   * æ£€æŸ¥å¹¶è¯·æ±‚é€šçŸ¥æƒé™
   * ä¿®å¤é€»è¾‘ï¼šå¿…é¡»ç­‰å¾…ç”¨æˆ·æ“ä½œç»“æŸåï¼Œå†æ¬¡æŸ¥è¯¢çœŸå®çš„å¼€å…³çŠ¶æ€ï¼Œè€Œä¸æ˜¯ç›´æ¥è¿”å› true
   */
  static async checkAndRequestPermission(context: common.UIAbilityContext): Promise<boolean> {
    try {
      // 1. åˆæ¬¡æ£€æŸ¥
      const isEnabled = await notificationManager.isNotificationEnabled();
      if (isEnabled) {
        return true;
      }

      // 2. è¯·æ±‚æƒé™ (å¼¹çª—)
      logger.info('Notification disabled, requesting permission...');
      await notificationManager.requestEnableNotification(context);

      // 3. å†æ¬¡æ£€æŸ¥æœ€ç»ˆç»“æœ (å…³é”®æ­¥éª¤)
      return await notificationManager.isNotificationEnabled();
    } catch (err) {
      logger.error(`Request notification permission failed: ${JSON.stringify(err)}`);
      return false;
    }
  }

  /**
   * å‘å¸ƒæ—¥å†æé†’
   * @param context ä¸Šä¸‹æ–‡
   * @param eventId äº‹ä»¶ID (ç”¨äºé€šçŸ¥å»é‡å’Œå‚æ•°ä¼ é€’)
   * @param title æ ‡é¢˜
   * @param content å†…å®¹
   * @param triggerTime è§¦å‘æ—¶é—´æˆ³
   */
  static async publishCalendarReminder(context: common.UIAbilityContext, eventId: number, title: string,
    content: string, triggerTime: number): Promise<number> {
    const now = new Date().getTime();

    // 1. æ—¶é—´æ ¡éªŒ (ä¿®å¤ï¼šç»™äºˆ 1 åˆ†é’Ÿçš„å®½é™æœŸï¼Œé˜²æ­¢æ¯«ç§’çº§å»¶è¿Ÿå¯¼è‡´æ ¡éªŒå¤±è´¥)
    if (triggerTime < now - 60000) {
      logger.warn(`Time passed. Trigger: ${triggerTime}, Now: ${now}`);
      return -1;
    }

    const date = new Date(triggerTime);

    try {
      // 2. å‡†å¤‡ WantAgentInfo (ä¿®å¤ï¼šè¡¥å…¨ action å’Œ entities)
      const wantInfo: wantAgent.WantAgentInfo = {
        wants: [
          {
            bundleName: context.abilityInfo.bundleName,
            abilityName: context.abilityInfo.name,
            // å¿…é¡»åŠ ï¼šåŒ¹é… module.json5 çš„ actionï¼Œç³»ç»Ÿæ®æ­¤è¯†åˆ«å…¥å£
            action: 'ohos.want.action.home',
            // å¿…é¡»åŠ ï¼šåŒ¹é… module.json5 çš„ entities
            entities: ['entity.system.home'],
            parameters: {
              // ä¸šåŠ¡å‚æ•°ï¼šç‚¹å‡»é€šçŸ¥åè·³è½¬åˆ°è¯¦æƒ…é¡µ
              'targetPage': 'EventDetailPage',
              'eventId': eventId,
              // ç³»ç»Ÿå‚æ•°ï¼šé˜²æ­¢ Intent è¢«ç³»ç»Ÿå»é‡æ‹¦æˆª
              'fromNotification': true
            }
          }
        ],
        // ä½¿ç”¨ START_ABILITY å¯åŠ¨åº”ç”¨
        operationType: wantAgent.OperationType.START_ABILITY,
        requestCode: 0,
        // ä¿®å¤ï¼šä½¿ç”¨ REPLACE_ELEMENT ç¡®ä¿ eventId å‚æ•°è¢«æ›´æ–°ï¼Œè€Œä¸æ˜¯æ²¿ç”¨æ—§çš„
        wantAgentFlags: [wantAgent.WantAgentFlags.REPLACE_ELEMENT]
      };

      // 3. è·å– WantAgent
      const agent = await wantAgent.getWantAgent(wantInfo);

      // ğŸ“ [ä¿®å¤] é¢„å…ˆè§£æå›½é™…åŒ–å­—ç¬¦ä¸²ï¼Œå› ä¸º actionButton.title åªæ¥å— string
      const closeTitle = context.resourceManager.getStringSync($r('app.string.notification_action_close').id);
      const snoozeTitle = context.resourceManager.getStringSync($r('app.string.notification_action_snooze').id);

      // 4. æ„å»ºæé†’è¯·æ±‚å¯¹è±¡
      const reminderRequest: reminderAgentManager.ReminderRequestCalendar = {
        reminderType: reminderAgentManager.ReminderType.REMINDER_TYPE_CALENDAR,
        dateTime: {
          year: date.getFullYear(),
          month: date.getMonth() + 1,
          day: date.getDate(),
          hour: date.getHours(),
          minute: date.getMinutes(),
          second: 0
        },
        content: content,
        title: title,

        // å“é“ƒæ—¶é•¿ï¼š60ç§’
        ringDuration: 60,

        // ç¨åæé†’è®¾ç½®ï¼šå…è®¸1æ¬¡ï¼Œé—´éš”5åˆ†é’Ÿ
        snoozeTimes: 1,
        timeInterval: 5 * 60,

        // ä½¿ç”¨ eventId ä½œä¸º notificationIdï¼Œæ–¹ä¾¿åç»­æ›´æ–°æˆ–å–æ¶ˆ
        notificationId: eventId,

        // ç»‘å®šç‚¹å‡»è·³è½¬åŠ¨ä½œ
        wantAgent: agent as ESObject,

        // äº¤äº’æŒ‰é’®
        actionButton: [
          { title: closeTitle, type: reminderAgentManager.ActionButtonType.ACTION_BUTTON_TYPE_CLOSE },
          { title: snoozeTitle, type: reminderAgentManager.ActionButtonType.ACTION_BUTTON_TYPE_SNOOZE }
        ]
      };

      // 5. å‘å¸ƒæé†’
      const reminderId = await reminderAgentManager.publishReminder(reminderRequest);
      logger.info(`[Success] Calendar reminder published. ID: ${reminderId}`);
      return reminderId;

    } catch (err) {
      logger.error(`[ERROR] Publish failed. Code:${err.code}, Message:${err.message}`);
      return -1;
    }
  }

  /**
   * å–æ¶ˆæé†’
   * @param reminderId æé†’ID
   */
  static async cancelReminder(reminderId: number): Promise<void> {
    if (reminderId < 0) {
      return;
    }
    try {
      await reminderAgentManager.cancelReminder(reminderId);
      logger.info(`Reminder ${reminderId} canceled.`);
    } catch (err) {
      logger.error(`Cancel reminder failed code:${err.code} message:${err.message}`);
    }
  }
}