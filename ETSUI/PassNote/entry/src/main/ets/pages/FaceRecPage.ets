/*
 * Copyright (c) 2026 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import router from '@ohos.router';
import { PassType, PasswordManager, RouterUtil } from '../common/Config';
import { BioAuthManager, BioAuthConfig } from '../common/BioAuthConfig';
import { PromptAction, UIContext } from '@kit.ArkUI';
import { AlertDialog } from '@kit.ArkUI';

enum FaceRecStatus {
  IDLE = 'idle',
  PREPARING = 'preparing',
  POSITIONING = 'positioning',
  SCANNING = 'scanning',
  VERIFYING = 'verifying',
  SUCCESS = 'success',
  FAILED = 'failed',
  LOCKED = 'locked'
}

enum FacePosition {
  TOO_CLOSE = 'too_close',
  TOO_FAR = 'too_far',
  TOO_LEFT = 'too_left',
  TOO_RIGHT = 'too_right',
  TOO_UP = 'too_up',
  TOO_DOWN = 'too_down',
  PERFECT = 'perfect'
}

@Entry
@Component
export struct FaceRecPage {
  private authType: PassType = PassType.FACE;

  @State currentStatus: FaceRecStatus = FaceRecStatus.IDLE;
  @State facePosition: FacePosition = FacePosition.PERFECT;
  @State progress: number = 0;
  @State scanQuality: number = 80;
  @State attempts: number = 0;
  @State maxAttempts: number = BioAuthConfig.FACE.MAX_ATTEMPTS;
  @State lockTime: number = BioAuthConfig.FACE.LOCK_TIME;
  @State countdown: number = 0;
  @State isUsingMock: boolean = true;
  @State faceBoxX: number = 0;
  @State faceBoxY: number = 0;
  @State faceBoxSize: number = 100;
  @State showGuide: boolean = true;
  @State faceSupported: boolean = true;

  uiContext: UIContext = this.getUIContext();
  promptAction: PromptAction = this.uiContext.getPromptAction();

  private prepareTimer?: number;
  private positionTimer?: number;
  private scanTimer?: number;
  private resetTimer?: number;
  private lockTimer?: number;

  dialoglockFace: CustomDialogController = new CustomDialogController({
    builder: AlertDialog({
      primaryTitle: 'äººè„¸è¯†åˆ«å·²é”å®š',
      content: `è¿ç»­å¤±è´¥${this.maxAttempts}æ¬¡ï¼Œè¯·${this.lockTime}ç§’åå†è¯•\nå»ºè®®ï¼šç¡®ä¿ç¯å¢ƒå…‰çº¿å……è¶³ï¼Œé¢éƒ¨æ— é®æŒ¡`,
      primaryButton: {
        value: 'ä½¿ç”¨å…¶ä»–æ–¹å¼',
        fontColor: '#007DFF',
        action: () => router.pushUrl({ url: 'pages/PasswordEntry' })
      },
      secondaryButton: {
        value: 'çŸ¥é“äº†',
        fontColor: '#007DFF',
        action: () => router.pushUrl({ url: 'pages/Index' })
      }
    })
  });

  get isLocked(): boolean {
    return this.currentStatus === FaceRecStatus.LOCKED;
  }

  get canStartScan(): boolean {
    if (!this.faceSupported) return false;
    return !this.isLocked && this.currentStatus === FaceRecStatus.IDLE;
  }

  get isScanning(): boolean {
    return this.currentStatus === FaceRecStatus.SCANNING ||
      this.currentStatus === FaceRecStatus.VERIFYING;
  }

  aboutToAppear() {
    const params = router.getParams() as Record<string, string>;
    if (params?.authType) {
      this.authType = params.authType as PassType;
    }

    this.checkFaceRecSupport();
    this.faceBoxX = 150;
    this.faceBoxY = 150;
  }

  aboutToDisappear() {
    this.clearAllTimers();
  }

  private clearAllTimers() {
    if (this.prepareTimer) clearTimeout(this.prepareTimer);
    if (this.positionTimer) clearInterval(this.positionTimer);
    if (this.scanTimer) clearInterval(this.scanTimer);
    if (this.resetTimer) clearTimeout(this.resetTimer);
    if (this.lockTimer) clearInterval(this.lockTimer);

    this.prepareTimer = undefined;
    this.positionTimer = undefined;
    this.scanTimer = undefined;
    this.resetTimer = undefined;
    this.lockTimer = undefined;
  }

  async checkFaceRecSupport() {
    const ctx = this.uiContext.getHostContext();
    const isDebug = !!ctx?.applicationInfo?.debug;

    if (isDebug) {
      this.isUsingMock = true;
      this.faceSupported = true;
      console.info('äººè„¸è¯†åˆ«: Preview æ¨¡æ‹Ÿæ¨¡å¼');
      return;
    }

    const supported = await BioAuthManager.checkFaceSupport();
    this.faceSupported = supported;
    this.isUsingMock = false;

    if (!supported) {
      this.promptAction.openToast({
        message: 'å½“å‰è®¾å¤‡ä¸æ”¯æŒäººè„¸è¯†åˆ«ï¼Œè¯·ä½¿ç”¨å…¶ä»–æ–¹å¼',
        duration: 2500
      });
    }

    console.info('äººè„¸è¯†åˆ«: ', supported ? 'çœŸæœºæ”¯æŒäººè„¸' : 'çœŸæœºä¸æ”¯æŒäººè„¸');
  }


  async startFaceRecognition() {
    if (!this.canStartScan) return;

    this.showGuide = false;

    if (this.isUsingMock) {
      this.currentStatus = FaceRecStatus.PREPARING;
      this.prepareTimer = setTimeout(() => {
        this.currentStatus = FaceRecStatus.POSITIONING;
        this.startFacePositioning();
      }, 800);
    } else {
      this.currentStatus = FaceRecStatus.VERIFYING;
      this.processFaceScan();
    }
  }

  startFacePositioning() {
    this.positionTimer = setInterval(() => {
      const offsetX = Math.random() * 80 - 40;
      const offsetY = Math.random() * 60 - 30;
      const offsetSize = Math.random() * 30 - 15;

      this.faceBoxX = 150 + offsetX;
      this.faceBoxY = 150 + offsetY;
      this.faceBoxSize = 100 + offsetSize;

      this.updateFacePosition(offsetX, offsetY, offsetSize);

      if (this.facePosition === FacePosition.PERFECT) {
        clearInterval(this.positionTimer);
        this.positionTimer = undefined;
        this.startFaceScanning();
      }
    }, 200);
  }

  updateFacePosition(offsetX: number, offsetY: number, offsetSize: number) {
    if (offsetSize > 20) {
      this.facePosition = FacePosition.TOO_CLOSE;
    } else if (offsetSize < -15) {
      this.facePosition = FacePosition.TOO_FAR;
    } else if (offsetX > 30) {
      this.facePosition = FacePosition.TOO_RIGHT;
    } else if (offsetX < -30) {
      this.facePosition = FacePosition.TOO_LEFT;
    } else if (offsetY > 20) {
      this.facePosition = FacePosition.TOO_DOWN;
    } else if (offsetY < -20) {
      this.facePosition = FacePosition.TOO_UP;
    } else {
      this.facePosition = FacePosition.PERFECT;
    }
  }


  async startFaceScanning() {
    this.currentStatus = FaceRecStatus.SCANNING;
    this.progress = 0;

    this.scanTimer = setInterval(() => {
      this.progress += 5;
      this.scanQuality = 70 + Math.random() * 30;

      if (this.progress >= 100) {
        clearInterval(this.scanTimer);
        this.scanTimer = undefined;
        this.processFaceScan();
      }
    }, 100);
  }

  async processFaceScan() {
    this.currentStatus = FaceRecStatus.VERIFYING;

    this.prepareTimer = setTimeout(async () => {
      if (this.isUsingMock) {
        await this.handleMockVerification();
      } else {
        await this.handleRealVerification();
      }
    }, 600);
  }

  async handleMockVerification() {
    const isSuccess = Math.random() < (0.7 * this.scanQuality / 100);
    isSuccess ? await this.handleSuccess() : await this.handleFailure();
  }

  async handleRealVerification() {
    try {
      const success = await BioAuthManager.authenticateFace();
      success ? await this.handleSuccess() : await this.handleFailure();
    } catch (e) {
      console.error('äººè„¸è¯†åˆ«å¼‚å¸¸', e);
      await this.handleFailure();
    }
  }

  async handleSuccess() {
    this.clearAllTimers();

    this.currentStatus = FaceRecStatus.SUCCESS;
    this.attempts = 0;

    await this.playSuccessAnimation();

    PasswordManager.setLastUsedAuth(this.authType);
    await new Promise<void>(r => setTimeout(r, 800));
    RouterUtil.goToHome();
  }

  async handleFailure() {
    this.clearAllTimers();

    this.attempts++;
    await this.playErrorAnimation();
    this.promptAction.openToast({
      message: `äººè„¸è¯†åˆ«å¤±è´¥ï¼Œè¿˜å¯å°è¯• ${this.maxAttempts - this.attempts} æ¬¡`,
      duration: 2000
    });
    this.currentStatus = FaceRecStatus.FAILED;

    if (this.attempts >= this.maxAttempts) {
      await this.lockFaceRecognition();
      return;
    }

    this.resetTimer = setTimeout(() => {
      this.resetScanner();
    }, 3000);
  }

  async lockFaceRecognition() {
    this.clearAllTimers();

    this.currentStatus = FaceRecStatus.LOCKED;
    this.countdown = this.lockTime;
    this.dialoglockFace.open();

    this.lockTimer = setInterval(() => {
      this.countdown--;
      if (this.countdown <= 0) {
        clearInterval(this.lockTimer);
        this.lockTimer = undefined;
        this.resetLock();
      }
    }, 1000);
  }

  resetLock() {
    this.currentStatus = FaceRecStatus.IDLE;
    this.attempts = 0;
    this.countdown = 0;
    this.showGuide = true;

    this.promptAction.openToast({
      message: 'äººè„¸è¯†åˆ«å·²è§£é”ï¼Œå¯ä»¥é‡è¯•',
      duration: 2000
    });
  }

  resetScanner() {
    if (!this.isLocked) {
      this.currentStatus = FaceRecStatus.IDLE;
      this.progress = 0;
      this.facePosition = FacePosition.PERFECT;
      this.showGuide = true;
      this.faceBoxX = 150;
      this.faceBoxY = 150;
      this.faceBoxSize = 100;
    }
  }

// æ’­æ”¾æˆåŠŸåŠ¨ç”»
  private async playSuccessAnimation() {
    // äººè„¸æ¡†å˜ä¸ºç»¿è‰²å¹¶æ”¾å¤§
    for (let i = 0; i < 3; i++) {
      await new Promise<void>(resolve => setTimeout(resolve, 200));
    }
  }

  // æ’­æ”¾å¤±è´¥åŠ¨ç”»
  private async playErrorAnimation() {
    // äººè„¸æ¡†é—ªçƒçº¢è‰²
    for (let i = 0; i < 3; i++) {
      await new Promise<void>(resolve => setTimeout(resolve, 150));
    }
  }

  // è·å–ä½ç½®æç¤ºæ–‡æœ¬
  getPositionText(): string {
    switch (this.facePosition) {
      case FacePosition.TOO_CLOSE:
        return 'è¯·ç¨å¾®è¿œç¦»æ‘„åƒå¤´';
      case FacePosition.TOO_FAR:
        return 'è¯·é è¿‘ä¸€äº›';
      case FacePosition.TOO_LEFT:
        return 'è¯·å‘å³ç§»åŠ¨ä¸€ç‚¹';
      case FacePosition.TOO_RIGHT:
        return 'è¯·å‘å·¦ç§»åŠ¨ä¸€ç‚¹';
      case FacePosition.TOO_UP:
        return 'è¯·ç¨å¾®å‘ä¸‹ç§»åŠ¨';
      case FacePosition.TOO_DOWN:
        return 'è¯·ç¨å¾®å‘ä¸Šç§»åŠ¨';
      case FacePosition.PERFECT:
        return 'ä½ç½®å®Œç¾ï¼Œä¿æŒä¸åŠ¨';
      default:
        return 'è¯·å°†é¢éƒ¨ç½®äºæ¡†å†…';
    }
  }

  // è·å–çŠ¶æ€æè¿°æ–‡æœ¬
  getStatusText(): string {
    switch (this.currentStatus) {
      case FaceRecStatus.IDLE:
        return 'ç‚¹å‡»å¼€å§‹äººè„¸è¯†åˆ«';
      case FaceRecStatus.PREPARING:
        return 'å‡†å¤‡ä¸­...';
      case FaceRecStatus.POSITIONING:
        return 'æ­£åœ¨å®šä½äººè„¸...';
      case FaceRecStatus.SCANNING:
        return `æ‰«æä¸­... ${this.progress}%`;
      case FaceRecStatus.VERIFYING:
        return 'æ­£åœ¨éªŒè¯èº«ä»½...';
      case FaceRecStatus.SUCCESS:
        return 'è¯†åˆ«æˆåŠŸï¼';
      case FaceRecStatus.FAILED:
        return `è¯†åˆ«å¤±è´¥ (${this.attempts}/${this.maxAttempts})`;
      case FaceRecStatus.LOCKED:
        return `å·²é”å®šï¼Œ${this.countdown}ç§’åé‡è¯•`;
      default:
        return 'äººè„¸è¯†åˆ«';
    }
  }

  // è·å–äººè„¸æ¡†é¢œè‰²
  getFaceBoxColor(): string {
    switch (this.currentStatus) {
      case FaceRecStatus.SUCCESS:
        return '#4CD964'; // ç»¿è‰²
      case FaceRecStatus.FAILED:
        return '#FF3B30'; // çº¢è‰²
      case FaceRecStatus.SCANNING:
      case FaceRecStatus.VERIFYING:
        return '#007AFF'; // è“è‰²
      case FaceRecStatus.POSITIONING:
        return this.facePosition === FacePosition.PERFECT ? '#4CD964' : '#FF9500'; // ç»¿è‰²æˆ–æ©™è‰²
      case FaceRecStatus.LOCKED:
        return '#8E8E93'; // ç°è‰²
      default:
        return '#007AFF'; // è“è‰²
    }
  }

  // è·å–æŒ‰é’®æ–‡æœ¬
  getButtonText(): string {
    if (!this.faceSupported) {
      return 'è®¾å¤‡ä¸æ”¯æŒäººè„¸è¯†åˆ«';
    }
    if (this.isLocked) {
      return 'å·²é”å®š';
    } else if (this.isScanning) {
      return 'è¯†åˆ«ä¸­...';
    } else if (this.currentStatus === FaceRecStatus.SUCCESS) {
      return 'éªŒè¯æˆåŠŸ';
    } else if (this.currentStatus === FaceRecStatus.FAILED && this.attempts < this.maxAttempts) {
      return 'é‡æ–°å°è¯•';
    } else {
      return 'å¼€å§‹äººè„¸è¯†åˆ«';
    }
  }

  // æŒ‰é’®æ˜¯å¦å¯ç”¨
  isButtonEnabled(): boolean {
    return this.canStartScan;
  }

  // è¿”å›ä¸Šä¸€é¡µ
  goBack() {
    router.back();
  }

  // åˆ‡æ¢åˆ°å…¶ä»–è®¤è¯æ–¹å¼
  switchToOtherAuth() {
    router.pushUrl({
      url: 'pages/PasswordEntry'
    });
  }

  build() {
    Column({ space: 0 }) {
      // é¡¶éƒ¨å¯¼èˆªæ 
      this.buildHeader()

      // äººè„¸è¯†åˆ«åŒºåŸŸ
      this.buildFaceRecArea()

      // çŠ¶æ€å’Œæ§åˆ¶åŒºåŸŸ
      this.buildControlArea()
    }
    .width('100%')
    .height('100%')
    .backgroundColor('#000000') // é»‘è‰²èƒŒæ™¯æ¨¡æ‹Ÿæ‘„åƒå¤´é¢„è§ˆ
  }

  // æ„å»ºé¡¶éƒ¨å¯¼èˆªæ 
  @Builder
  buildHeader() {
    Row({ space: 10 }) {
      // è¿”å›æŒ‰é’®
      Button('â†')
        .width(40)
        .height(40)
        .fontSize(20)
        .backgroundColor('#1A1A1A')  // æ·±ç°è‰²èƒŒæ™¯
        .fontColor(Color.White)
        .borderRadius(20)
        .border({ width: 1, color: '#FFFFFF40' }) // å¯é€‰ï¼šåŠ ä¸ªæµ…è‰²è¾¹æ¡†
        .onClick(() => this.goBack())

      Text('äººè„¸è¯†åˆ«')
        .fontSize(20)
        .fontWeight(FontWeight.Bold)
        .fontColor(Color.White)
        .layoutWeight(1)
        .textAlign(TextAlign.Center)

      // æ¨¡å¼æŒ‡ç¤ºå™¨
      if (this.isUsingMock) {
        Text('æ¨¡æ‹Ÿ')
          .fontSize(12)
          .fontColor('#FF9500')
          .padding({ left: 8, right: 8, top: 4, bottom: 4 })
          .backgroundColor('#FFF3E080')
          .borderRadius(10)
      }
    }
    .width('100%')
    .padding({ left: 15, right: 15, top: 10, bottom: 10 })
    .backgroundColor('#00000080')
  }

  // æ„å»ºäººè„¸è¯†åˆ«åŒºåŸŸ
  @Builder
  buildFaceRecArea() {
    Stack() {
      // æ‘„åƒå¤´é¢„è§ˆèƒŒæ™¯ï¼ˆæ¨¡æ‹Ÿï¼‰
      Column()
        .width('100%')
        .height(400)
        .backgroundColor('#000000')
        .border({
          width: 2,
          color: '#555555',
          radius: 8,
          style: BorderStyle.Dashed // è™šçº¿è¾¹æ¡†
        })
      // å¼•å¯¼æ¡†å’Œæç¤º
      if (this.showGuide && this.currentStatus === FaceRecStatus.IDLE) {
        this.buildGuideOverlay()
      }

      // äººè„¸å®šä½æ¡†ï¼ˆæ¨¡æ‹Ÿï¼‰
      if (this.isUsingMock &&
        this.currentStatus === FaceRecStatus.POSITIONING ||
        this.currentStatus === FaceRecStatus.SCANNING ||
        this.currentStatus === FaceRecStatus.VERIFYING) {
        this.buildFaceBox()
      }

      // æ‰«ææ•ˆæœ
      if (this.isUsingMock && this.currentStatus === FaceRecStatus.SCANNING) {
        this.buildScanningEffect()
      }

      // æˆåŠŸ/å¤±è´¥è¦†ç›–å±‚
      if (this.currentStatus === FaceRecStatus.SUCCESS ||
        this.currentStatus === FaceRecStatus.FAILED) {
        this.buildResultOverlay()
      }
    }
    .width('100%')
    .height(400)
    .margin({ top: 10 })
  }

  // æ„å»ºå¼•å¯¼è¦†ç›–å±‚
  @Builder
  buildGuideOverlay() {
    Column({ space: 20 }) {
      // äººè„¸å›¾æ ‡
      Text('ğŸ‘¤')
        .fontSize(60)
        .margin({ bottom: 10 })

      Text('äººè„¸è¯†åˆ«')
        .fontSize(24)
        .fontWeight(FontWeight.Bold)
        .fontColor(Color.White)

      Text('è¯·å°†é¢éƒ¨å¯¹å‡†æ‘„åƒå¤´')
        .fontSize(16)
        .fontColor('#CCCCCC')
        .margin({ bottom: 20 })

      // å¼•å¯¼æç¤ºåˆ—è¡¨
      Column({ space: 12 }) {
        Row({ space: 10 }) {
          Text('âœ“')
            .fontSize(16)
            .fontColor('#4CD964')
          Text('ç¡®ä¿ç¯å¢ƒå…‰çº¿å……è¶³')
            .fontSize(14)
            .fontColor('#CCCCCC')
        }

        Row({ space: 10 }) {
          Text('âœ“')
            .fontSize(16)
            .fontColor('#4CD964')
          Text('é¢éƒ¨æ— é®æŒ¡ï¼ˆçœ¼é•œã€å£ç½©ç­‰ï¼‰')
            .fontSize(14)
            .fontColor('#CCCCCC')
        }

        Row({ space: 10 }) {
          Text('âœ“')
            .fontSize(16)
            .fontColor('#4CD964')
          Text('ä¿æŒæ‰‹æœºç¨³å®š')
            .fontSize(14)
            .fontColor('#CCCCCC')
        }
      }
      .alignItems(HorizontalAlign.Start)
      .margin({ left: 50, right: 50 })
    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.Center)
    .alignItems(HorizontalAlign.Center)
    .backgroundColor('#00000080')
  }

  // æ„å»ºäººè„¸æ¡†
  @Builder
  buildFaceBox() {
    Stack() {
      // å¤–æ¡†
      Column()
        .width(this.faceBoxSize)
        .height(this.faceBoxSize)
        .border({
          width: 3,
          color: this.getFaceBoxColor(),
          style: BorderStyle.Solid
        })
        .borderRadius(20)
        .position({ x: this.faceBoxX - this.faceBoxSize/2, y: this.faceBoxY - this.faceBoxSize/2 })

      // å››ä¸ªè§’
      // å·¦ä¸Šè§’
      Column()
        .width(20)
        .height(20)
        .border({
          width: 4,
          color: this.getFaceBoxColor(),
          style: BorderStyle.Solid
        })
        // åˆ†åˆ«è®¾ç½®æ¯ä¸ªè§’çš„åœ†è§’
        .borderRadius({
          topLeft: 0,        // å·¦ä¸Šè§’ä¸åœ†è§’
          topRight: 4,
          bottomLeft: 4,
          bottomRight: 4
        })
        .clip(true)
        .position({ x: this.faceBoxX - this.faceBoxSize/2 - 10, y: this.faceBoxY - this.faceBoxSize/2 - 10 })
      // å³ä¸Šè§’
      Column()
        .width(20)
        .height(20)
        .border({
          width: 4,
          color: this.getFaceBoxColor(),
          style: BorderStyle.Solid
        })
        .borderRadius(4)
        // åˆ†åˆ«è®¾ç½®æ¯ä¸ªè§’çš„åœ†è§’
        .borderRadius({
          topLeft: 4,        // å³ä¸Šè§’ä¸åœ†è§’
          topRight: 0,
          bottomLeft: 4,
          bottomRight: 4
        })
        .clip(true)
        .position({ x: this.faceBoxX + this.faceBoxSize/2 - 10, y: this.faceBoxY - this.faceBoxSize/2 - 10 })

      // å·¦ä¸‹è§’
      Column()
        .width(20)
        .height(20)
        .border({
          width: 4,
          color: this.getFaceBoxColor(),
          style: BorderStyle.Solid
        })
        .borderRadius(4)
        // åˆ†åˆ«è®¾ç½®æ¯ä¸ªè§’çš„åœ†è§’
        .borderRadius({
          topLeft: 4,        // å·¦ä¸‹è§’ä¸åœ†è§’
          topRight: 4,
          bottomLeft: 0,
          bottomRight: 4
        })
        .clip(true)
        .position({ x: this.faceBoxX - this.faceBoxSize/2 - 10, y: this.faceBoxY + this.faceBoxSize/2 - 10 })

      // å³ä¸‹è§’
      Column()
        .width(20)
        .height(20)
        .border({
          width: 4,
          color: this.getFaceBoxColor(),
          style: BorderStyle.Solid
        })
        .borderRadius(4)
        // åˆ†åˆ«è®¾ç½®æ¯ä¸ªè§’çš„åœ†è§’
        .borderRadius({
          topLeft: 4,        // å³ä¸‹è§’ä¸åœ†è§’
          topRight: 4,
          bottomLeft: 4,
          bottomRight: 0
        })
        .clip(true)
        .position({ x: this.faceBoxX + this.faceBoxSize/2 - 10, y: this.faceBoxY + this.faceBoxSize/2 - 10 })

      // ä½ç½®æç¤ºæ–‡æœ¬
      if (this.currentStatus === FaceRecStatus.POSITIONING) {
        Text(this.getPositionText())
          .fontSize(16)
          .fontColor(this.getFaceBoxColor())
          .fontWeight(FontWeight.Medium)
          .position({ x: this.faceBoxX - 100, y: this.faceBoxY + this.faceBoxSize/2 + 20 })
          .width(200)
          .textAlign(TextAlign.Center)
      }
    }
  }

  // æ„å»ºæ‰«ææ•ˆæœ
  @Builder
  buildScanningEffect() {
    // æ‰«æçº¿æ•ˆæœ
    Column()
      .width(this.faceBoxSize)
      .height(4)
      .backgroundColor('#007AFF80')
      .position({
        x: this.faceBoxX - this.faceBoxSize/2,
        y: this.faceBoxY - this.faceBoxSize/2 + (this.progress/100) * this.faceBoxSize
      })

    // è´¨é‡æŒ‡ç¤ºå™¨
    Text(`è´¨é‡: ${this.scanQuality.toFixed(0)}%`)
      .fontSize(14)
      .fontColor('#FFFFFF')
      .position({ x: this.faceBoxX + this.faceBoxSize/2 + 20, y: this.faceBoxY })
  }

  // æ„å»ºç»“æœè¦†ç›–å±‚
  @Builder
  buildResultOverlay() {
    Column({ space: 15 }) {
      if (this.currentStatus === FaceRecStatus.SUCCESS) {
        Text('âœ“')
          .fontSize(60)
          .fontColor('#4CD964')

        Text('éªŒè¯æˆåŠŸ')
          .fontSize(24)
          .fontWeight(FontWeight.Bold)
          .fontColor('#4CD964')
      } else {
        Text('âœ—')
          .fontSize(60)
          .fontColor('#FF3B30')

        Text('éªŒè¯å¤±è´¥')
          .fontSize(24)
          .fontWeight(FontWeight.Bold)
          .fontColor('#FF3B30')
      }
    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.Center)
    .alignItems(HorizontalAlign.Center)
    .backgroundColor('#00000080')
  }

  // æ„å»ºæ§åˆ¶åŒºåŸŸ
  @Builder
  buildControlArea() {
    Column({ space: 20 }) {
      // çŠ¶æ€æ–‡æœ¬
      Text(this.getStatusText())
        .fontSize(18)
        .fontColor(Color.White)
        .fontWeight(FontWeight.Medium)
        .margin({ top: 20 })

      // è¿›åº¦æ¡ï¼ˆæ‰«ææ—¶æ˜¾ç¤ºï¼‰
      if (this.isScanning) {
        Column({ space: 10 }) {
          Progress({
            value: this.progress,
            total: 100,
            type: ProgressType.Linear
          })
            .width('80%')
            .height(6)
            .linearGradient({
              angle: 90,
              colors: [[0x007AFF, 0], [0x4CD964, 1]]
            })
            .backgroundColor('#FFFFFF40')
            .borderRadius(3)

          if (this.currentStatus === FaceRecStatus.SCANNING) {
            Text('æ­£åœ¨é‡‡é›†é¢éƒ¨ç‰¹å¾...')
              .fontSize(14)
              .fontColor('#CCCCCC')
          } else if (this.currentStatus === FaceRecStatus.VERIFYING) {
            Text('æ­£åœ¨ä¸æ³¨å†Œä¿¡æ¯æ¯”å¯¹...')
              .fontSize(14)
              .fontColor('#CCCCCC')
          }
        }
        .margin({ top: 10 })
      }

      // å°è¯•æ¬¡æ•°å’Œé”å®šä¿¡æ¯
      Column({ space: 10 }) {
        if (this.attempts > 0 && !this.isLocked) {
          Text(`å°è¯•æ¬¡æ•°: ${this.attempts}/${this.maxAttempts}`)
            .fontSize(14)
            .fontColor(this.attempts >= 2 ? '#FF9500' : '#CCCCCC')
        }

        if (this.isLocked) {
          Column({ space: 15 }) {
            Text(`é”å®šå‰©ä½™æ—¶é—´: ${this.countdown}ç§’`)
              .fontSize(16)
              .fontColor('#FF3B30')
              .fontWeight(FontWeight.Medium)

            Progress({
              value: this.countdown,
              total: this.lockTime,
              type: ProgressType.Ring
            })
              .width(60)
              .height(60)
              .color('#FF3B30')

            Text('è¿ç»­å¤šæ¬¡è¯†åˆ«å¤±è´¥ï¼Œè¯·ç¨åå†è¯•')
              .fontSize(12)
              .fontColor('#FF9500')
              .margin({ top: 10 })
          }
          .margin({ top: 20 })
        }
      }
      .margin({ top: 20 })

      // æ“ä½œæŒ‰é’®
      Column({ space: 15 }) {
        // ä¸»æ“ä½œæŒ‰é’®
        Button(this.getButtonText())
          .width('80%')
          .height(50)
          .backgroundColor(this.isButtonEnabled() ? '#007AFF' : '#666666')
          .fontSize(18)
          .fontColor(Color.White)
          .borderRadius(25)
          .enabled(this.isButtonEnabled())
          .onClick(() => this.startFaceRecognition())

        // åˆ‡æ¢è®¤è¯æ–¹å¼æŒ‰é’®
        if (this.currentStatus !== FaceRecStatus.SCANNING &&
          this.currentStatus !== FaceRecStatus.VERIFYING &&
          this.currentStatus !== FaceRecStatus.SUCCESS) {
          Button('ä½¿ç”¨å…¶ä»–æ–¹å¼è®¤è¯')
            .width('80%')
            .height(40)
            .backgroundColor('#1A1A1A')  // æ·±ç°è‰²èƒŒæ™¯
            .fontSize(14)
            .fontColor(Color.White)     // ç™½è‰²æ–‡å­—
            .borderRadius(20)
            .border({ width: 1, color: '#FFFFFF40' }) // å¯é€‰ï¼šåŠ ä¸ªæµ…è‰²è¾¹æ¡†
            .onClick(() => this.switchToOtherAuth())
        }
      }
      .margin({ top: 30, bottom: 40 })
    }
    .width('100%')
    .padding(20)
    .alignItems(HorizontalAlign.Center)
  }
}