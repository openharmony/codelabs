/*
 * Copyright (c) 2026 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * æ‰“å¡æ—¶æ®µåˆ†æå¡ç‰‡ (TimeAnalysisCard)
 * ------------------------------------------------
 * ä¿®æ”¹è®°å½•ï¼š
 * 1. å°† TimeBar ä» @Builder æ”¹ä¸ºç‹¬ç«‹çš„ @Component ç»„ä»¶ï¼Œè§£å†³ UI ä¸åˆ·æ–°çš„ Bugã€‚
 * 2. å¢åŠ  @Prop å’Œ @Watch ç¡®ä¿æ•°æ®æµå‘çš„ç»å¯¹æ­£ç¡®ã€‚
 */
@Component
export struct TimeAnalysisCard {
  // 1. æ ¸å¿ƒæ•°æ®æºï¼ŒåŠ ä¸Š @Watch ç›‘å¬å˜åŒ–
  @Prop @Watch('analyze') timeStamps: number[] = [];
  // 2. ç»Ÿè®¡çŠ¶æ€
  @State morningCount: number = 0;
  @State afternoonCount: number = 0;
  @State nightCount: number = 0;
  @State totalCount: number = 0; // æ–°å¢ï¼šç”¨äºä¼ ç»™å­ç»„ä»¶è®¡ç®—ç™¾åˆ†æ¯”
  // 3. æ ‡ç­¾çŠ¶æ€
  @State userTag: string = 'è®¡ç®—ä¸­...';

  // ç»„ä»¶åŠ è½½æ—¶å…ˆç®—ä¸€æ¬¡
  aboutToAppear() {
    this.analyze();
  }

  // æ ¸å¿ƒåˆ†æé€»è¾‘ (æ”¹è‰¯ç‰ˆ)
  analyze() {
    console.info(`[TimeCard] å¼€å§‹åˆ†æï¼Œæ”¶åˆ°äº† ${this.timeStamps.length} æ¡æ•°æ®`);

    // 1. æ›´æ–°æ€»æ•°
    this.totalCount = this.timeStamps.length;

    if (this.totalCount === 0) {
      this.userTag = 'æš‚æ— æ•°æ®';
      this.morningCount = 0;
      this.afternoonCount = 0;
      this.nightCount = 0;
      return;
    }

    // 2. ç»Ÿè®¡å„æ—¶æ®µ
    let m = 0, a = 0, n = 0;
    this.timeStamps.forEach(ts => {
      const date = new Date(ts);
      const hour = date.getHours();
      if (hour >= 4 && hour < 12) {
        m++;
      } else if (hour >= 12 && hour < 18) {
        a++;
      } else {
        n++;
      }
    });

    // 3. æ›´æ–° UI çŠ¶æ€
    this.morningCount = m;
    this.afternoonCount = a;
    this.nightCount = n;

    // 4. ğŸ†• æ”¹è‰¯åçš„æ ‡ç­¾åˆ¤å®šé€»è¾‘
    const max = Math.max(m, a, n);

    // åˆ¤æ–­å“ªäº›æ—¶æ®µå¹¶åˆ—ç¬¬ä¸€
    const isM = (m === max);
    const isA = (a === max);
    const isN = (n === max);

    if (isM && isA && isN) {
      // ä¸‰è€…éƒ½ä¸€æ ·
      this.userTag = 'âš–ï¸ æ—¶é—´ç®¡ç†å¤§å¸ˆ';
    } else if (isM && isA) {
      // æ—©æ™¨ + ä¸‹åˆ å¹¶åˆ—
      this.userTag = 'ğŸƒ å…¨å¤©åœ¨çº¿';
    } else if (isM && isN) {
      // æ—©æ™¨ + æ·±å¤œ å¹¶åˆ— (èµ·å¾—æ—©ç¡å¾—æ™š)
      this.userTag = 'âš¡ ç©¶æå·ç‹';
    } else if (isA && isN) {
      // ä¸‹åˆ + æ·±å¤œ å¹¶åˆ—
      this.userTag = 'ğŸŒ™ è¶Šå¤œè¶Šå—¨';
    } else if (isM) {
      // ä»…æ—©æ™¨æœ€å¤š
      this.userTag = 'ğŸŒ æ—©èµ·é¸Ÿ';
    } else if (isA) {
      // ä»…ä¸‹åˆæœ€å¤š
      this.userTag = 'â˜• ä¸‹åˆèŒ¶è¾¾äºº';
    } else {
      // ä»…æ·±å¤œæœ€å¤š
      this.userTag = 'ğŸ¦‰ å¤œçŒ«å­';
    }

    console.info(`[TimeCard] åˆ¤å®šæ ‡ç­¾ä¸º: ${this.userTag}`);
  }

  build() {
    Column() {
      // --- é¡¶éƒ¨æ ‡é¢˜æ  ---
      Row() {
        Text('æ—¶æ®µåˆ†å¸ƒ')
          .fontSize(16)
          .fontWeight(FontWeight.Bold)
          .fontColor('#333')

        Blank()

        // æ ‡ç­¾
        if (this.totalCount > 0) {
          Text(this.userTag)
            .fontSize(10)
            .fontColor(Color.White)
            .backgroundColor('#FF9F0A')
            .padding({
              left: 8,
              right: 8,
              top: 2,
              bottom: 2
            })
            .borderRadius(10)
        }
      }
      .width('100%')
      .margin({ bottom: 15 })

      // --- è¿›åº¦æ¡åˆ—è¡¨ ---
      Column() {
        // ä½¿ç”¨ç‹¬ç«‹çš„å­ç»„ä»¶ï¼Œé€šè¿‡ @Prop ä¼ é€’æ•°æ®ï¼Œå¼ºåˆ¶åˆ·æ–°
        TimeBarItem({
          label: 'æ—©æ™¨',
          count: this.morningCount,
          total: this.totalCount,
          color: '#FFCC00'
        })

        TimeBarItem({
          label: 'ä¸‹åˆ',
          count: this.afternoonCount,
          total: this.totalCount,
          color: '#FF9500'
        })

        TimeBarItem({
          label: 'æ·±å¤œ',
          count: this.nightCount,
          total: this.totalCount,
          color: '#5856D6'
        })
      }
    }
    .width('100%')
    .padding(20)
    .backgroundColor(Color.White)
    .borderRadius(16)
    .shadow({
      radius: 5,
      color: '#05000000',
      offsetX: 2,
      offsetY: 2
    })
  }
}

/**
 * ğŸ†• æå–å‡ºæ¥çš„å­ç»„ä»¶ï¼šå•æ¡è¿›åº¦æ¡
 * ä½¿ç”¨ @Component å®šä¹‰ï¼Œç¡®ä¿æ¥æ”¶åˆ°æ–°çš„ @Prop æ—¶å¿…å®šåˆ·æ–° UI
 */
@Component
struct TimeBarItem {
  @Prop label: string;
  @Prop count: number; // æ¥æ”¶å…·ä½“çš„æ¬¡æ•°
  @Prop total: number; // æ¥æ”¶æ€»æ•°
  @Prop color: string;

  // è®¡ç®—ç™¾åˆ†æ¯”çš„è¾…åŠ©æ–¹æ³•
  getPercent(): number {
    if (this.total === 0) {
      return 0;
    }
    return (this.count / this.total) * 100;
  }

  build() {
    Row() {
      // å·¦ä¾§æ ‡ç­¾
      Text(this.label)
        .fontSize(12)
        .fontColor('#666')
        .width(40)
        .fontWeight(FontWeight.Regular)

      // ä¸­é—´è¿›åº¦æ¡
      Stack({ alignContent: Alignment.Start }) {
        // åº•æ§½
        Row()
          .width('100%')
          .height(8)
          .backgroundColor('#F1F3F5')
          .borderRadius(4)

        // è¿›åº¦
        Row()
          .width(`${this.getPercent()}%`)
          .height(8)
          .backgroundColor(this.color)
          .borderRadius(4)
          .animation({ duration: 600, curve: Curve.FastOutSlowIn })
      }
      .layoutWeight(1)
      .margin({ left: 10, right: 10 })

      // å³ä¾§å…·ä½“æ¬¡æ•°
      Text(`${this.count}æ¬¡`)
        .fontSize(12)
        .fontColor('#333')
        .width(35)
        .textAlign(TextAlign.End)
    }
    .width('100%')
    .margin({ bottom: 12 })
  }
}