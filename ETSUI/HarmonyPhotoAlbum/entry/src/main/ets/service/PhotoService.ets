/*
 * Copyright (c) 2023 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import relationalStore from '@ohos.data.relationalStore';
import { PhotoModel } from '../model/PhotoModel';
import Constants from '../common/constants/Constants';
import common from '@ohos.app.ability.common';

class PhotoService {
  // æ•°æ®åº“æ“ä½œå®ä¾‹
  private rdbStore: relationalStore.RdbStore | null = null;

  /**
   * åˆå§‹åŒ–æ•°æ®åº“
   * @param context åº”ç”¨ä¸Šä¸‹æ–‡
   */
  initDB(context: common.UIAbilityContext): Promise<void> {
    const config: relationalStore.StoreConfig = {
      name: Constants.RDB_NAME,
      securityLevel: relationalStore.SecurityLevel.S1
    };

    return new Promise((resolve, reject) => {
      relationalStore.getRdbStore(context, config, (err, store) => {
        if (err) {
          console.error(`[PhotoService] è·å–æ•°æ®åº“å¤±è´¥: ${err.code}, ${err.message}`);
          reject(err);
          return;
        }

        this.rdbStore = store;
        // å¦‚æœè¡¨ä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºè¡¨
        if (this.rdbStore) {
          this.rdbStore.executeSql(Constants.CREATE_TABLE_SQL);
          console.info('[PhotoService] æ•°æ®åº“åˆå§‹åŒ–æˆåŠŸï¼Œè¡¨å·²å°±ç»ª');
        }
        resolve();
      });
    });
  }

  /**
   * æ’å…¥ä¸€å¼ å›¾ç‰‡æ•°æ®
   * @param photo å›¾ç‰‡å¯¹è±¡ (idå¯ä¼ 0ï¼Œå› ä¸ºæ˜¯è‡ªå¢çš„)
   * @returns Promise<number> è¿”å›æ’å…¥è¡Œçš„ rowId
   */
  insert(photo: PhotoModel): Promise<number> {
    if (!this.rdbStore) {
      console.error('[PhotoService] æ•°æ®åº“æœªåˆå§‹åŒ–');
      return Promise.reject('DB not initialized');
    }

    const valueBucket: relationalStore.ValuesBucket = {};

    valueBucket[Constants.COL_NAME] = photo.name;
    valueBucket[Constants.COL_PATH] = photo.path;
    valueBucket[Constants.COL_CATEGORY] = photo.category;
    valueBucket[Constants.COL_CREATE_TIME] = photo.createTime;
    valueBucket[Constants.COL_TAGS] = photo.tags;

    return this.rdbStore.insert(Constants.PHOTO_TABLE_NAME, valueBucket);
  }

  /**
   * æŸ¥è¯¢æ‰€æœ‰å›¾ç‰‡
   * @returns Promise<PhotoModel[]> å›¾ç‰‡åˆ—è¡¨
   */
  queryAll(): Promise<PhotoModel[]> {
    if (!this.rdbStore) {
      return Promise.reject('DB not initialized');
    }

    // æ„å»ºæŸ¥è¯¢æ¡ä»¶ (è¿™é‡ŒæŸ¥è¯¢æ‰€æœ‰)
    let predicates = new relationalStore.RdbPredicates(Constants.PHOTO_TABLE_NAME);
    // æŒ‰åˆ›å»ºæ—¶é—´å€’åºæ’åˆ— (æœ€æ–°çš„åœ¨æœ€å‰)
    predicates.orderByDesc(Constants.COL_CREATE_TIME);

    return this.rdbStore.query(predicates).then((resultSet) => {
      let count = resultSet.rowCount;
      console.info(`[PhotoService] æŸ¥è¯¢åˆ° ${count} æ¡è®°å½•`);

      let result: PhotoModel[] = [];
      if (count === 0) {
        resultSet.close();
        return result;
      }

      resultSet.goToFirstRow();
      do {
        // ä»ç»“æœé›†ä¸­æå–æ•°æ®
        const id = resultSet.getDouble(resultSet.getColumnIndex(Constants.COL_ID));
        const name = resultSet.getString(resultSet.getColumnIndex(Constants.COL_NAME));
        const path = resultSet.getString(resultSet.getColumnIndex(Constants.COL_PATH));
        const category = resultSet.getString(resultSet.getColumnIndex(Constants.COL_CATEGORY));
        const createTime = resultSet.getDouble(resultSet.getColumnIndex(Constants.COL_CREATE_TIME));
        const tags = resultSet.getString(resultSet.getColumnIndex(Constants.COL_TAGS));

        result.push(new PhotoModel(id, name, path, category, createTime, tags));
      } while (resultSet.goToNextRow());

      resultSet.close();
      return result;
    });
  }

  // ==========================================
  // æ–°å¢ï¼šæœç´¢å’Œåˆ†ç±»åŠŸèƒ½
  // ==========================================

  /**
   * æ ¹æ®åˆ†ç±»æŸ¥è¯¢å›¾ç‰‡
   * @param category åˆ†ç±»åç§°
   * @returns Promise<PhotoModel[]> å›¾ç‰‡åˆ—è¡¨
   */
  queryByCategory(category: string): Promise<PhotoModel[]> {
    if (!this.rdbStore) {
      console.error('[PhotoService] æ•°æ®åº“æœªåˆå§‹åŒ–');
      return Promise.reject('DB not initialized');
    }

    let predicates = new relationalStore.RdbPredicates(Constants.PHOTO_TABLE_NAME);
    predicates.equalTo(Constants.COL_CATEGORY, category);
    predicates.orderByDesc(Constants.COL_CREATE_TIME);

    return this.rdbStore.query(predicates).then((resultSet) => {
      return this.parseResultSet(resultSet);
    });
  }

  /**
   * æœç´¢å›¾ç‰‡ï¼ˆæ”¯æŒåç§°ã€åˆ†ç±»å’Œæ ‡ç­¾æœç´¢ï¼‰
   * @param keyword æœç´¢å…³é”®è¯
   * @returns Promise<PhotoModel[]> å›¾ç‰‡åˆ—è¡¨
   */
  searchPhotos(keyword: string): Promise<PhotoModel[]> {
    if (!this.rdbStore) {
      console.error('[PhotoService] æ•°æ®åº“æœªåˆå§‹åŒ–');
      return Promise.reject('DB not initialized');
    }

    if (!keyword || keyword.trim() === '') {
      return this.queryAll();
    }

    let predicates = new relationalStore.RdbPredicates(Constants.PHOTO_TABLE_NAME);

    // ==========================================
    // ğŸ”§ ä¿®å¤ï¼šæœç´¢åç§°ã€åˆ†ç±»æˆ–æ ‡ç­¾åŒ…å«å…³é”®è¯çš„å›¾ç‰‡
    // ==========================================
    predicates.like(Constants.COL_NAME, `%${keyword}%`)
      .or()
      .like(Constants.COL_CATEGORY, `%${keyword}%`) // ğŸ†• æ·»åŠ åˆ†ç±»æœç´¢
      .or()
      .like(Constants.COL_TAGS, `%${keyword}%`);

    predicates.orderByDesc(Constants.COL_CREATE_TIME);

    return this.rdbStore.query(predicates).then((resultSet) => {
      return this.parseResultSet(resultSet);
    });
  }

  /**
   * ç»„åˆæœç´¢ï¼šæŒ‰åˆ†ç±»å’Œå…³é”®è¯æœç´¢
   * @param category åˆ†ç±»ï¼ˆä¼  'å…¨éƒ¨' è¡¨ç¤ºä¸é™åˆ†ç±»ï¼‰
   * @param keyword æœç´¢å…³é”®è¯
   * @returns Promise<PhotoModel[]> å›¾ç‰‡åˆ—è¡¨
   */
  searchPhotosByCategoryAndKeyword(category: string, keyword: string): Promise<PhotoModel[]> {
    if (!this.rdbStore) {
      console.error('[PhotoService] æ•°æ®åº“æœªåˆå§‹åŒ–');
      return Promise.reject('DB not initialized');
    }

    console.info(`[PhotoService] ğŸ” ç»„åˆæœç´¢ - åˆ†ç±»: "${category}", å…³é”®è¯: "${keyword}"`);

    let predicates = new relationalStore.RdbPredicates(Constants.PHOTO_TABLE_NAME);

    // ==========================================
    // ğŸ”§ ä¿®å¤ï¼šåˆ†ç±»å’Œå…³é”®è¯æœç´¢é€»è¾‘
    // ==========================================

    // æƒ…å†µ1ï¼šåªé€‰æ‹©åˆ†ç±»ï¼Œæ— å…³é”®è¯ â†’ æŒ‰åˆ†ç±»æŸ¥è¯¢
    if ((category && category !== 'å…¨éƒ¨') && (!keyword || keyword.trim() === '')) {
      predicates.equalTo(Constants.COL_CATEGORY, category);
      console.info(`[PhotoService] ğŸ“‚ æŒ‰åˆ†ç±»æŸ¥è¯¢: ${category}`);
    }
    // æƒ…å†µ2ï¼šé€‰æ‹©"å…¨éƒ¨"ï¼Œæœ‰å…³é”®è¯ â†’ å…¨å±€æœç´¢
    else if ((category === 'å…¨éƒ¨' || !category) && keyword && keyword.trim() !== '') {
      predicates.beginWrap()
        .like(Constants.COL_NAME, `%${keyword}%`)
        .or()
        .like(Constants.COL_CATEGORY, `%${keyword}%`) // ğŸ†• æ·»åŠ åˆ†ç±»æœç´¢
        .or()
        .like(Constants.COL_TAGS, `%${keyword}%`)
        .endWrap();
      console.info(`[PhotoService] ğŸ” å…¨å±€æœç´¢: ${keyword}`);
    }
    // æƒ…å†µ3ï¼šæ—¢æœ‰åˆ†ç±»åˆæœ‰å…³é”®è¯ â†’ å…ˆç­›é€‰åˆ†ç±»ï¼Œå†æœç´¢
    else if ((category && category !== 'å…¨éƒ¨') && (keyword && keyword.trim() !== '')) {
      predicates.equalTo(Constants.COL_CATEGORY, category)
        .and()
        .beginWrap()
        .like(Constants.COL_NAME, `%${keyword}%`)
        .or()
        .like(Constants.COL_TAGS, `%${keyword}%`)
        .endWrap();
      console.info(`[PhotoService] ğŸ”ğŸ“‚ åˆ†ç±»+æœç´¢: ${category} + ${keyword}`);
    }
    // æƒ…å†µ4ï¼šéƒ½ä¸ºç©º â†’ æŸ¥è¯¢å…¨éƒ¨
    else {
      console.info(`[PhotoService] ğŸ“‹ æŸ¥è¯¢å…¨éƒ¨`);
    }

    predicates.orderByDesc(Constants.COL_CREATE_TIME);

    return this.rdbStore.query(predicates).then((resultSet) => {
      const result = this.parseResultSet(resultSet);
      console.info(`[PhotoService] âœ… æŸ¥è¯¢ç»“æœ: ${result.length} æ¡`);
      return result;
    });
  }

  /**
   * è·å–æ‰€æœ‰åˆ†ç±»åˆ—è¡¨ï¼ˆå»é‡ï¼‰
   * @returns Promise<string[]> åˆ†ç±»åˆ—è¡¨
   */
  getCategories(): Promise<string[]> {
    if (!this.rdbStore) {
      console.error('[PhotoService] æ•°æ®åº“æœªåˆå§‹åŒ–');
      return Promise.reject('DB not initialized');
    }

    let predicates = new relationalStore.RdbPredicates(Constants.PHOTO_TABLE_NAME);

    return this.rdbStore.query(predicates, [Constants.COL_CATEGORY]).then((resultSet) => {
      let categories: string[] = [];
      let count = resultSet.rowCount;

      if (count === 0) {
        resultSet.close();
        return categories;
      }

      resultSet.goToFirstRow();
      do {
        const category = resultSet.getString(resultSet.getColumnIndex(Constants.COL_CATEGORY));
        if (category && category.trim() !== '' && !categories.includes(category)) {
          categories.push(category);
        }
      } while (resultSet.goToNextRow());

      resultSet.close();
      return categories;
    });
  }

  /**
   * è§£ææŸ¥è¯¢ç»“æœé›†ï¼ˆæå–å…¬å…±é€»è¾‘ï¼‰
   * @param resultSet æŸ¥è¯¢ç»“æœé›†
   * @returns PhotoModel[] å›¾ç‰‡åˆ—è¡¨
   */
  private parseResultSet(resultSet: relationalStore.ResultSet): PhotoModel[] {
    let count = resultSet.rowCount;
    console.info(`[PhotoService] æŸ¥è¯¢åˆ° ${count} æ¡è®°å½•`);

    let result: PhotoModel[] = [];
    if (count === 0) {
      resultSet.close();
      return result;
    }

    resultSet.goToFirstRow();
    do {
      const id = resultSet.getDouble(resultSet.getColumnIndex(Constants.COL_ID));
      const name = resultSet.getString(resultSet.getColumnIndex(Constants.COL_NAME));
      const path = resultSet.getString(resultSet.getColumnIndex(Constants.COL_PATH));
      const category = resultSet.getString(resultSet.getColumnIndex(Constants.COL_CATEGORY));
      const createTime = resultSet.getDouble(resultSet.getColumnIndex(Constants.COL_CREATE_TIME));
      const tags = resultSet.getString(resultSet.getColumnIndex(Constants.COL_TAGS));

      result.push(new PhotoModel(id, name, path, category, createTime, tags));
    } while (resultSet.goToNextRow());

    resultSet.close();
    return result;
  }
}
// å¯¼å‡ºå•ä¾‹å¯¹è±¡ï¼Œæ–¹ä¾¿å¤–éƒ¨ç›´æ¥è°ƒç”¨
export default new PhotoService();